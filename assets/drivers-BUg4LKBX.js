const b=o=>new Promise(e=>setTimeout(e,o));function O(o,e,t){const i=[0,3,2,4,1,5,6,7];let n=0,s,r,a;return o>=e/t?(a=0,n=e/dlkDiv):o>=e/(t+t/2)?(a=1,n=e/(t+t/2)):o>=e/(2*t)?(a=2,n=e/(2*t)):(s=e*16/t/o,s&1?r=s/2+1:r=s/2,r>131072&&(r=131071),n=e*16/t/r,n&1?n=n/2+1:n=n/2,a=r>>3|i[r&7]<<14),[n,a]}function C(o){let e,t,i,n;if(o<=0)throw new Error("Baud rate must be > 0");return[e,t]=O(o,48e6,16),i=t&65535,n=t>>16,[e,i,n]}class se extends EventTarget{dtr=!0;rts=!0;constructor(e,t){super();const i=this;(async()=>{if(e==null)throw new Error("Could not find device");await e.open(),console.log("Opened:",e.opened),e.configuration===null&&(console.log("selectConfiguration"),await e.selectConfiguration(1)),await e.claimInterface(0),await e.selectConfiguration(1),await e.selectAlternateInterface(0,0);const[n,s,r]=C(t.baudRate);console.log("Setting baud rate to",n),await e.controlTransferOut({requestType:"vendor",recipient:"device",request:3,value:s,index:r}),i.device=e,i.isClosing=!1;const a=await e.controlTransferOut({requestType:"vendor",recipient:"device",request:0,value:0,index:1});console.debug("reset result: ",a);const h=await e.controlTransferOut({requestType:"vendor",recipient:"device",request:1,value:(this.dtr?257:256)|(this.rts?514:512),index:1});console.debug("set control lines result: ",h),this.device.transferIn(1,64),i.readLoop(),i.dispatchEvent(new Event("ready"))})().catch(n=>{console.log("Error during FTDI setup:",n),i.dispatchEvent(new CustomEvent("error",{detail:n}))})}async readLoop(){let e;try{e=await this.device.transferIn(1,64)}catch(t){t.message.indexOf("LIBUSB_TRANSFER_NO_DEVICE")?(console.log("Device disconnected"),this.isClosing=!0,this.dispatchEvent(new Event("disconnected"))):console.log("Error reading data:",t)}if(e&&e.data&&e.data.byteLength&&e.data.byteLength>2){console.log(`Received ${e.data.byteLength-2} byte(s).`);const t=new Uint8Array(e.data.buffer);this.dispatchEvent(new CustomEvent("data",{detail:t.slice(2)}))}!this.isClosing&&this.device.opened&&this.readLoop()}async read(){const{data:{buffer:e,byteLength:t}}=await this.device.transferIn(1,64),i=new Uint8Array(e);return t===2?this.read():{bytesRead:t-2,data:i.slice(2)}}async writeAsync(e){return await this.device.transferOut(2,e)}write(e,t){this.writeAsync(e).then(()=>{t()},i=>t(i))}async closeAsync(){this.isClosing=!0,this.dispatchEvent(new Event("disconnected"));try{console.log("Sending EOT"),await this.writeAsync([4]),await b(2e3),await this.device.releaseInterface(0),await this.device.close(),console.log("Closed device")}catch(e){console.log("Error:",e)}}close(e){(async()=>(await this.closeAsync(),e()))()}}const S=[75,150,300,600,1200,1800,2400,3600,4800,7200,9600,14400,19200,28800,38400,57600,115200,230400,460800,614400,921600,1228800,2457600,3e6,6e6],A=1e3,N=5e3,I=34,f=1,E=2,D=1,m=1,w=129,U=128,x=7,B=8,F=9,$=1,M=2,G=135,W=2,H=4,q=1,V=8,Q=128,P=64,X=32,k=128,J=8,_=1,R=2,y=8,p=128;class re extends EventTarget{constructor(e,t){super(),this.isClosing=!1,this.bitrate=9600,this.deviceType=2,this.currentFlowControl=0,this.currentControlLinesValue=E|f,this.bitrate=t.baudRate,this.device=e}async controlTransferInWithTimeout({requestType:e,recipient:t,request:i,value:n,index:s},r,a=A){return new Promise((h,d)=>{const l=new AbortController,u=c=>{l.signal.removeEventListener("abort",u),d(c.target)};l.signal.addEventListener("abort",u),setTimeout(()=>{l.abort("controlTransferIn timed out")},a),this.device.controlTransferIn({requestType:e,recipient:t,request:i,value:n,index:s},r).then(c=>{l.signal.aborted?d(`aborted, but we finally got our result: ${JSON.stringify(c)}`):c.data?.byteLength===r?h(c.data.buffer):d("controlTransferIn succeeded, but did not receive expected number of bytes")}).catch(d)})}async controlTransferOutWithTimeout({requestType:e,recipient:t,request:i,value:n,index:s,data:r},a=N){return new Promise((h,d)=>{const l=new AbortController,u=c=>{l.signal.removeEventListener("abort",u),d(c.target)};l.signal.addEventListener("abort",u),setTimeout(()=>{l.abort("controlTransferOut timed out")},a),this.device.controlTransferOut({requestType:e,recipient:t,request:i,value:n,index:s},r).then(c=>{l.signal.aborted?d(`aborted, but we finally got our result: ${JSON.stringify(c)}`):c.bytesWritten===(r?r.byteLength:0)?h(c.status):d("controlTransferOut succeeded, but did not write expected number of bytes")}).catch(d)})}async testHxStatus(){return this.controlTransferInWithTimeout({requestType:"vendor",recipient:"device",request:D,value:32896,index:0},1).then(()=>!0).catch(()=>!1)}async vendorRead(e,t){const i=(this.deviceType===3,w);return(await this.device.controlTransferIn({requestType:"vendor",recipient:"device",request:i,value:e,index:t},1)).data?.buffer}async vendorWrite(e,t){const i=this.deviceType===3?U:m;await this.device.controlTransferOut({requestType:"class",recipient:"device",request:i,value:e,index:t}).then(n=>{console.log(`vendorWrite success ${JSON.stringify(n)}`)}).catch(n=>{console.warn(`vendorWrite failed ${n}`)})}async setBaudRate(e){const i=S.slice().sort((r,a)=>Math.abs(r-e)-Math.abs(a-e))[0];await this.device.controlTransferIn({requestType:"class",recipient:"interface",request:33,value:0,index:0},7),console.log("Setting baud rate to",i);const n=new ArrayBuffer(7),s=new DataView(n);s.setInt32(0,i,!0),s.setUint8(4,0),s.setUint8(5,0),s.setUint8(6,8),await this.device.controlTransferOut({requestType:"class",recipient:"interface",request:32,value:0,index:0},s)}async purgeHwBuffers(e,t){if(this.deviceType===3){let i=0;e&&(i|=$),t&&(i|=M),i!==0&&await this.vendorWrite(x,i)}else e&&await this.vendorWrite(B,0),t&&await this.vendorWrite(F,0)}async resetDevice(){return this.purgeHwBuffers(!0,!0)}async open(){return await(async()=>{await this.device.open(),[this.iface]=this.device.configuration?this.device.configuration.interfaces:[],console.log("Claiming interface",this.iface.interfaceNumber),await this.device.claimInterface(this.iface.interfaceNumber),this.iface.alternate.endpoints.forEach(r=>{switch(r.direction){case"in":this.readEndpoint=r;break;case"out":this.writeEndpoint=r;break;default:console.error(`endpoint ${r.endpointNumber} has unexpected direction: ${r.direction}`);break}});const t=(await this.device.controlTransferIn({requestType:"standard",recipient:"device",request:6,value:256,index:0},255)).data;if(!t||t.byteLength<14)throw"Could not get device descriptors.";const i=this.device.usbVersionMajor,n=this.device.deviceVersionMajor,s=t.getInt8(7);if(this.device.deviceClass===2||s!=64)this.deviceType=0;else if(i===512){const r=await this.testHxStatus();r&&n===768?this.deviceType=1:r&&n===1280?this.deviceType=1:this.deviceType=3}else this.deviceType=2;await this.resetDevice(),await this.doBlackMagic(),await this.setControlLines(this.currentControlLinesValue),await this.setFlowControl(this.currentFlowControl),await this.setBaudRate(this.bitrate),this.isClosing=!1,this.dispatchEvent(new Event("ready")),await this.readLoop()})().catch(e=>{console.log("Error during PL2303 setup:",e),this.dispatchEvent(new CustomEvent("error",{detail:e}))})}async readLoop(){if(!this.readEndpoint){console.error("no read endpoint, aborting readLoop()"),await this.close();return}this.device.transferIn(this.readEndpoint.endpointNumber,64).then(e=>{if(e&&e.data&&e.data.byteLength){console.log(`Received ${e.data.byteLength} byte(s).`);const t=new Uint8Array(e.data.buffer);this.dispatchEvent(new CustomEvent("data",{detail:t.slice(0)}))}else console.log("transferIn got no result, no result data, or data was empty")}).catch(e=>{e.message.indexOf("LIBUSB_TRANSFER_NO_DEVICE")?(console.warn("Device disconnected"),this.dispatchEvent(new Event("disconnected")),this.isClosing=!0):console.error("Error reading data:",e)}).finally(async()=>{!this.isClosing&&this.device.opened&&await this.readLoop()})}async close(){return this.isClosing=!0,this.dispatchEvent(new Event("disconnected")),new Promise((e,t)=>{setTimeout(async()=>{try{await this.device.releaseInterface(0),await this.device.close(),e()}catch(i){console.error("Error while closing:",i),t(i)}},2e3)})}async write(e){return new Promise((t,i)=>{if(!this.writeEndpoint){i("no writeEndpoint");return}this.device.transferOut(this.writeEndpoint?.endpointNumber,e).then(()=>{t({status:"ok",bytesWritten:e.byteLength})}).catch(n=>{console.error(`error writing to ${this.device.constructor.name}: ${n}`),i(n)})})}async doBlackMagic(){this.deviceType!==3&&(await this.vendorRead(33924,0),await this.vendorWrite(1028,0),await this.vendorRead(33924,0),await this.vendorRead(33667,0),await this.vendorRead(33924,0),await this.vendorWrite(1028,1),await this.vendorRead(33924,0),await this.vendorRead(33667,0),await this.vendorWrite(0,1),await this.vendorWrite(1,0),this.deviceType===0?await this.vendorWrite(2,36):await this.vendorWrite(2,68))}async setFlowControl(e){switch(console.log(`setFlowControl ${e}`),e){case 0:this.deviceType===3?await this.vendorWrite(10,255):await this.vendorWrite(0,0);break;case 1:this.deviceType==3?await this.vendorWrite(10,250):await this.vendorWrite(0,97);break;case 4:this.deviceType==3?await this.vendorWrite(10,238):await this.vendorWrite(0,193);break;default:throw`Unsupported flow control: ${e}`}this.currentFlowControl=e}async setDTR(e){let t;e?t=this.currentControlLinesValue|f:t=this.currentControlLinesValue&~f,await this.setControlLines(t)}async setRTS(e){let t;e?t=this.currentControlLinesValue|E:t=this.currentControlLinesValue&~E,await this.setControlLines(t)}async setControlLines(e){console.log(`setting control lines to '${(e>>>0).toString(2)}'`),await this.controlTransferOutWithTimeout({requestType:"class",recipient:"interface",request:I,value:e,index:0,data:void 0}),this.currentControlLinesValue=e}async getStatus(){const e=this.deviceType===3;console.log(`deviceType is ${this.deviceType}, isHxnDevice? ${e}`);const t=await this.vendorRead(e?Q:G,0);if(!t)return;const n=new Uint8Array(t)[0];let s=0;return e?(n&J||(s|=p),n&X||(s|=R),n&P||(s|=_),n&k||(s|=y)):(n&V||(s|=p),n&H||(s|=R),n&W||(s|=_),n&q||(s|=y)),console.log(`pl2303 status: ${(s>>>0).toString(2)}`),s}}const z=95,T=149,v=154,g=161,K=164,Y=4882,Z=3884,L=9496,j=128,ee=64,te=3,ie=32,ne=64,ae=6790,oe=29987,ce=21795;class de extends EventTarget{constructor(e,t){super(),this.isClosing=!1,this.bitrate=9600,this.dtr=!0,this.rts=!0,this.bitrate=t.baudRate,this.device=e}async vendorOut(e,t,i=0){await this.device.controlTransferOut({requestType:"vendor",recipient:"device",request:e,value:t,index:i}).then(n=>{console.log("vendorOut success ",n)}).catch(n=>{console.warn(`vendorOut failed ${n}`)})}async vendorIn(e,t,i,n){return this.device.controlTransferIn({requestType:"vendor",recipient:"device",request:e,value:t,index:i},n)}async checkState(e,t,i,n){const s=await this.vendorIn(t,i,0,n.byteLength);return s.status!=="ok"||!s.data?(console.error(`failed to send ${e}, status ${s.status}, data:`,s.data),!1):s.data.byteLength!==n.byteLength?(console.error(`error sending command ${e}, expected ${n.byteLength}, got ${s.data.byteLength} instead`),!1):s.data.buffer!==n?(console.error(`error sending command ${e}, expected `,n," got ",s.data.buffer),!1):!0}async setBaudRate(e){let t,i;if(e===921600)i=7,t=62208;else{for(t=1532620800/e,i=3;t>65520&&i>0;)t>>=3,i--;if(t>65520)throw console.error(`unsupported baud rate ${e}`),new Error(`unsupported baud rate ${e}`);t=65536-t}i|=128;const n=t&65280|i,s=t&255;console.debug(`set baud rate ${e}, v1=${n}, v2=${s}`),await this.vendorOut(v,Y,n),await this.vendorOut(v,Z,s)}async open(){(async()=>{await this.device.open();const e=this.device.configuration?this.device.configuration.interfaces:[];await Promise.all(e.map(async i=>{console.log("Claiming interface",i.interfaceNumber);try{return await this.device.claimInterface(i.interfaceNumber)}catch(n){return console.error("error claiming interface ",i,`;, reason: ${n}`)}})),e[e.length-1].alternate.endpoints.forEach(i=>{if(i.type==="bulk")switch(i.direction){case"in":this.readEndpoint=i;break;case"out":this.writeEndpoint=i;break;default:console.error(`endpoint ${i.endpointNumber} has unexpected direction: ${i.direction}`);break}else console.debug("ignoring non-bulk endpoint: ",i)}),await this.init(),await this.setBaudRate(this.bitrate),this.isClosing=!1,await this.readLoop(),this.dispatchEvent(new Event("ready"))})().catch(e=>{console.log("Error during CH34x setup:",e),this.dispatchEvent(new CustomEvent("error",{detail:e}))})}async readLoop(){if(!this.readEndpoint){console.error("no read endpoint, aborting readLoop()"),await this.close();return}this.device.transferIn(this.readEndpoint.endpointNumber,this.readEndpoint.packetSize).then(e=>{if(e&&e.data&&e.data.byteLength){console.log(`Received ${e.data.byteLength} byte(s).`);const t=new Uint8Array(e.data.buffer);this.dispatchEvent(new CustomEvent("data",{detail:t.slice(0)}))}else console.log("transferIn got no result, no result data, or data was empty")}).catch(e=>{e.message.indexOf("LIBUSB_TRANSFER_NO_DEVICE")?(console.warn("Device disconnected"),this.dispatchEvent(new Event("disconnected")),this.isClosing=!0):console.error("Error reading data:",e)}).finally(async()=>{!this.isClosing&&this.device.opened&&await this.readLoop()})}async close(){return this.isClosing=!0,this.dispatchEvent(new Event("disconnected")),new Promise((e,t)=>{setTimeout(async()=>{try{await this.device.releaseInterface(0),await this.device.close(),e()}catch(i){console.error("Error while closing:",i),t(i)}},2e3)})}async write(e){return new Promise((t,i)=>{if(!this.writeEndpoint){i("no writeEndpoint");return}this.device.transferOut(this.writeEndpoint?.endpointNumber,e).then(()=>{t({status:"ok",bytesWritten:e.byteLength})}).catch(n=>{console.error(`error writing to ${this.device.constructor.name}: ${n}`),i(n)})})}async setControlLines(){return this.vendorOut(K,~((this.dtr?ie:0)|(this.rts?ne:0)),0)}async init(){await this.checkState("init 1",z,0,new Uint8Array([-1,0])),await this.vendorOut(g,0,0),await this.setBaudRate(9600),await this.checkState("init 4",T,L,new Uint8Array([-1,0])),await this.vendorOut(v,L,ee|j|te),await this.checkState("init 6",T,1798,new Uint8Array([-1,-1])),await this.vendorOut(g,20511,55562),await this.setBaudRate(9600),await this.setControlLines(),await this.checkState("init 10",T,1798,new Uint8Array([-1,-1]))}}export{de as C,oe as P,ae as V,ce as a,re as b,se as f};
